/* tslint:disable */
/* eslint-disable */
/**
 * Overmind Backend
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  APIResponse,
  AssignTokenRoleRequest,
  AssignUserRoleRequest,
  AuthenticateTokenResponse,
  CreateChatbotExtensionTokenResponse,
  CreateOrganisationRequest,
  CreateProjectRequest,
  CreateTokenRequest,
  CreateTokenResponse,
  HTTPValidationError,
  ImpersonateRequest,
  InvitationListResponse,
  InvitationResponse,
  InvitationSignUpRequest,
  LoginRequest,
  LoginResponse,
  OrganisationListResponse,
  OrganisationResponse,
  PasswordResetConfirmRequest,
  PasswordResetRequest,
  ProjectListResponse,
  ProjectResponse,
  RoleListResponse,
  RoleScope,
  SAMLConfigRequest,
  SAMLConfigResponse,
  SAMLLoginRequest,
  SendInvitationRequest,
  SignUpRequest,
  SignUpResponse,
  TokenListResponse,
  TokenResponse,
  TokenRoleResponse,
  UpdateProjectRequest,
  UpdateTokenRequest,
  UserListResponse,
  UserResponse,
  UserRoleResponse,
} from '../models/index';
import {
    APIResponseFromJSON,
    APIResponseToJSON,
    AssignTokenRoleRequestFromJSON,
    AssignTokenRoleRequestToJSON,
    AssignUserRoleRequestFromJSON,
    AssignUserRoleRequestToJSON,
    AuthenticateTokenResponseFromJSON,
    AuthenticateTokenResponseToJSON,
    CreateChatbotExtensionTokenResponseFromJSON,
    CreateChatbotExtensionTokenResponseToJSON,
    CreateOrganisationRequestFromJSON,
    CreateOrganisationRequestToJSON,
    CreateProjectRequestFromJSON,
    CreateProjectRequestToJSON,
    CreateTokenRequestFromJSON,
    CreateTokenRequestToJSON,
    CreateTokenResponseFromJSON,
    CreateTokenResponseToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    ImpersonateRequestFromJSON,
    ImpersonateRequestToJSON,
    InvitationListResponseFromJSON,
    InvitationListResponseToJSON,
    InvitationResponseFromJSON,
    InvitationResponseToJSON,
    InvitationSignUpRequestFromJSON,
    InvitationSignUpRequestToJSON,
    LoginRequestFromJSON,
    LoginRequestToJSON,
    LoginResponseFromJSON,
    LoginResponseToJSON,
    OrganisationListResponseFromJSON,
    OrganisationListResponseToJSON,
    OrganisationResponseFromJSON,
    OrganisationResponseToJSON,
    PasswordResetConfirmRequestFromJSON,
    PasswordResetConfirmRequestToJSON,
    PasswordResetRequestFromJSON,
    PasswordResetRequestToJSON,
    ProjectListResponseFromJSON,
    ProjectListResponseToJSON,
    ProjectResponseFromJSON,
    ProjectResponseToJSON,
    RoleListResponseFromJSON,
    RoleListResponseToJSON,
    RoleScopeFromJSON,
    RoleScopeToJSON,
    SAMLConfigRequestFromJSON,
    SAMLConfigRequestToJSON,
    SAMLConfigResponseFromJSON,
    SAMLConfigResponseToJSON,
    SAMLLoginRequestFromJSON,
    SAMLLoginRequestToJSON,
    SendInvitationRequestFromJSON,
    SendInvitationRequestToJSON,
    SignUpRequestFromJSON,
    SignUpRequestToJSON,
    SignUpResponseFromJSON,
    SignUpResponseToJSON,
    TokenListResponseFromJSON,
    TokenListResponseToJSON,
    TokenResponseFromJSON,
    TokenResponseToJSON,
    TokenRoleResponseFromJSON,
    TokenRoleResponseToJSON,
    UpdateProjectRequestFromJSON,
    UpdateProjectRequestToJSON,
    UpdateTokenRequestFromJSON,
    UpdateTokenRequestToJSON,
    UserListResponseFromJSON,
    UserListResponseToJSON,
    UserResponseFromJSON,
    UserResponseToJSON,
    UserRoleResponseFromJSON,
    UserRoleResponseToJSON,
} from '../models/index';

export interface AddUserToProjectApiV1IamUsersProjectsProjectIdUsersUserIdPostRequest {
    projectId: string;
    userId: string;
    useCache?: boolean;
}

export interface AssignTokenRoleApiV1IamTokensTokenIdRolesPostRequest {
    tokenId: string;
    assignTokenRoleRequest: AssignTokenRoleRequest;
    useCache?: boolean;
}

export interface AssignUserRoleApiV1IamUsersUserIdRolesPostRequest {
    userId: string;
    assignUserRoleRequest: AssignUserRoleRequest;
    useCache?: boolean;
}

export interface AuthenticateTokenApiV1IamAuthAuthenticateTokenPostRequest {
    useCache?: boolean;
}

export interface ConfigureOrganisationSsoApiV1IamOrganisationsOrganisationIdSsoConfigPutRequest {
    organisationId: string;
    sAMLConfigRequest: SAMLConfigRequest;
    useCache?: boolean;
}

export interface CreateChatbotExtensionTokenApiV1IamChatbotExtensionTokenPostRequest {
    useCache?: boolean;
}

export interface CreateOrganisationApiV1IamOrganisationsPostRequest {
    createOrganisationRequest: CreateOrganisationRequest;
    useCache?: boolean;
}

export interface CreateProjectApiV1IamProjectsPostRequest {
    createProjectRequest: CreateProjectRequest;
    useCache?: boolean;
}

export interface CreateTokenApiV1IamTokensPostRequest {
    createTokenRequest: CreateTokenRequest;
    useCache?: boolean;
}

export interface DeactivateCurrentUserApiV1IamUsersMeDeleteRequest {
    useCache?: boolean;
}

export interface DeleteOrganisationEndpointApiV1IamOrganisationsOrganisationIdDeleteRequest {
    organisationId: string;
    useCache?: boolean;
}

export interface DeleteProjectApiV1IamProjectsProjectIdDeleteRequest {
    projectId: string;
    useCache?: boolean;
}

export interface DeleteTokenApiV1IamTokensTokenIdDeleteRequest {
    tokenId: string;
    useCache?: boolean;
}

export interface GetCurrentUserProfileApiV1IamUsersMeGetRequest {
    useCache?: boolean;
}

export interface GetOrganisationApiV1IamOrganisationsOrganisationIdGetRequest {
    organisationId: string;
    useCache?: boolean;
}

export interface GetOrganisationSsoConfigApiV1IamOrganisationsOrganisationIdSsoConfigGetRequest {
    organisationId: string;
    useCache?: boolean;
}

export interface GetProjectApiV1IamProjectsProjectIdGetRequest {
    projectId: string;
    useCache?: boolean;
}

export interface GetTokenApiV1IamTokensTokenIdGetRequest {
    tokenId: string;
    useCache?: boolean;
}

export interface ImpersonateApiV1IamUsersImpersonatePostRequest {
    impersonateRequest: ImpersonateRequest;
    useCache?: boolean;
}

export interface ListCoreRolesApiV1IamRolesGetRequest {
    scope?: RoleScope | null;
    useCache?: boolean;
}

export interface ListInvitationsApiV1IamInvitationsGetRequest {
    organisationId?: string | null;
    status?: string | null;
    useCache?: boolean;
}

export interface ListOrganisationUsersApiV1IamUsersOrganisationsOrganisationIdGetRequest {
    organisationId: string;
    useCache?: boolean;
}

export interface ListProjectUsersApiV1IamUsersProjectsProjectIdGetRequest {
    projectId: string;
    useCache?: boolean;
}

export interface ListTokenRolesApiV1IamTokensTokenIdRolesGetRequest {
    tokenId: string;
    useCache?: boolean;
}

export interface ListTokensApiV1IamTokensGetRequest {
    projectId: string;
    useCache?: boolean;
}

export interface ListUserOrganisationsApiV1IamOrganisationsGetRequest {
    useCache?: boolean;
}

export interface ListUserProjectsApiV1IamProjectsGetRequest {
    organisationId?: string | null;
    useCache?: boolean;
}

export interface ListUserRolesApiV1IamUsersUserIdRolesGetRequest {
    userId: string;
    scopeType?: string | null;
    scopeId?: string | null;
    useCache?: boolean;
}

export interface LoginApiV1IamUsersLoginPostRequest {
    loginRequest: LoginRequest;
}

export interface RemoveTokenRoleApiV1IamTokensTokenIdRolesTokenRoleIdDeleteRequest {
    tokenId: string;
    tokenRoleId: string;
    useCache?: boolean;
}

export interface RemoveUserFromOrganisationApiV1IamUsersOrganisationsOrganisationIdUsersUserIdDeleteRequest {
    organisationId: string;
    userId: string;
    useCache?: boolean;
}

export interface RemoveUserFromProjectApiV1IamUsersProjectsProjectIdUsersUserIdDeleteRequest {
    projectId: string;
    userId: string;
    useCache?: boolean;
}

export interface RemoveUserRoleApiV1IamUsersUserIdRolesUserRoleIdDeleteRequest {
    userId: string;
    userRoleId: string;
    useCache?: boolean;
}

export interface RequestPasswordResetApiV1IamUsersPasswordResetRequestPostRequest {
    passwordResetRequest: PasswordResetRequest;
}

export interface ResetPasswordApiV1IamUsersPasswordResetPostRequest {
    passwordResetConfirmRequest: PasswordResetConfirmRequest;
}

export interface RespondToInvitationApiV1IamInvitationsInvitationIdDecisionPostRequest {
    invitationId: string;
    decision: string;
    useCache?: boolean;
}

export interface RevokeInvitationApiV1IamInvitationsInvitationIdDeleteRequest {
    invitationId: string;
    useCache?: boolean;
}

export interface SamlAcsApiV1IamSamlAcsPostRequest {
    sAMLResponse: string;
    relayState: string;
}

export interface SamlLoginRequestApiV1IamSamlLoginPostRequest {
    sAMLLoginRequest: SAMLLoginRequest;
}

export interface SendInvitationApiV1IamInvitationsPostRequest {
    sendInvitationRequest: SendInvitationRequest;
    useCache?: boolean;
}

export interface SignupApiV1IamAuthSignupPostRequest {
    signUpRequest: SignUpRequest;
}

export interface SignupByInvitationApiV1IamAuthSignupByInvitationPostRequest {
    invitationSignUpRequest: InvitationSignUpRequest;
}

export interface UpdateOrganisationApiV1IamOrganisationsOrganisationIdPutRequest {
    organisationId: string;
    createOrganisationRequest: CreateOrganisationRequest;
    useCache?: boolean;
}

export interface UpdateProjectApiV1IamProjectsProjectIdPutRequest {
    projectId: string;
    updateProjectRequest: UpdateProjectRequest;
    useCache?: boolean;
}

export interface UpdateTokenApiV1IamTokensTokenIdPutRequest {
    tokenId: string;
    updateTokenRequest: UpdateTokenRequest;
    useCache?: boolean;
}

export interface ValidateInvitationTokenApiV1IamInvitationsValidateGetRequest {
    token: string;
}

export interface VerifyEmailApiV1IamAuthVerifyGetRequest {
    token: string;
}

/**
 * 
 */
export class IamApi extends runtime.BaseAPI {

    /**
     * Add a user to a project (membership only, no role assignment).  User must have ADMIN permission in the project or organisation.
     * Add User To Project
     */
    async addUserToProjectApiV1IamUsersProjectsProjectIdUsersUserIdPostRaw(requestParameters: AddUserToProjectApiV1IamUsersProjectsProjectIdUsersUserIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling addUserToProjectApiV1IamUsersProjectsProjectIdUsersUserIdPost().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling addUserToProjectApiV1IamUsersProjectsProjectIdUsersUserIdPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/users/projects/{project_id}/users/{user_id}`;
        urlPath = urlPath.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters['projectId'])));
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Add a user to a project (membership only, no role assignment).  User must have ADMIN permission in the project or organisation.
     * Add User To Project
     */
    async addUserToProjectApiV1IamUsersProjectsProjectIdUsersUserIdPost(requestParameters: AddUserToProjectApiV1IamUsersProjectsProjectIdUsersUserIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.addUserToProjectApiV1IamUsersProjectsProjectIdUsersUserIdPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Assign a role to an API token.  User must have MANAGE_TOKENS permission in the token\'s project. User must also have ASSIGN_ROLES permission in the relevant scope.
     * Assign Token Role
     */
    async assignTokenRoleApiV1IamTokensTokenIdRolesPostRaw(requestParameters: AssignTokenRoleApiV1IamTokensTokenIdRolesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenRoleResponse>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling assignTokenRoleApiV1IamTokensTokenIdRolesPost().'
            );
        }

        if (requestParameters['assignTokenRoleRequest'] == null) {
            throw new runtime.RequiredError(
                'assignTokenRoleRequest',
                'Required parameter "assignTokenRoleRequest" was null or undefined when calling assignTokenRoleApiV1IamTokensTokenIdRolesPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/tokens/{token_id}/roles`;
        urlPath = urlPath.replace(`{${"token_id"}}`, encodeURIComponent(String(requestParameters['tokenId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AssignTokenRoleRequestToJSON(requestParameters['assignTokenRoleRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenRoleResponseFromJSON(jsonValue));
    }

    /**
     * Assign a role to an API token.  User must have MANAGE_TOKENS permission in the token\'s project. User must also have ASSIGN_ROLES permission in the relevant scope.
     * Assign Token Role
     */
    async assignTokenRoleApiV1IamTokensTokenIdRolesPost(requestParameters: AssignTokenRoleApiV1IamTokensTokenIdRolesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenRoleResponse> {
        const response = await this.assignTokenRoleApiV1IamTokensTokenIdRolesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Assign a role to a user.  User must have MANAGE_USER_ROLES permission in the organisation. User must also have ASSIGN_ROLES permission in the relevant scope.
     * Assign User Role
     */
    async assignUserRoleApiV1IamUsersUserIdRolesPostRaw(requestParameters: AssignUserRoleApiV1IamUsersUserIdRolesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserRoleResponse>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling assignUserRoleApiV1IamUsersUserIdRolesPost().'
            );
        }

        if (requestParameters['assignUserRoleRequest'] == null) {
            throw new runtime.RequiredError(
                'assignUserRoleRequest',
                'Required parameter "assignUserRoleRequest" was null or undefined when calling assignUserRoleApiV1IamUsersUserIdRolesPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/users/{user_id}/roles`;
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AssignUserRoleRequestToJSON(requestParameters['assignUserRoleRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserRoleResponseFromJSON(jsonValue));
    }

    /**
     * Assign a role to a user.  User must have MANAGE_USER_ROLES permission in the organisation. User must also have ASSIGN_ROLES permission in the relevant scope.
     * Assign User Role
     */
    async assignUserRoleApiV1IamUsersUserIdRolesPost(requestParameters: AssignUserRoleApiV1IamUsersUserIdRolesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserRoleResponse> {
        const response = await this.assignUserRoleApiV1IamUsersUserIdRolesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Authenticate a token.
     * Authenticate Token
     */
    async authenticateTokenApiV1IamAuthAuthenticateTokenPostRaw(requestParameters: AuthenticateTokenApiV1IamAuthAuthenticateTokenPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticateTokenResponse>> {
        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/auth/authenticate-token`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticateTokenResponseFromJSON(jsonValue));
    }

    /**
     * Authenticate a token.
     * Authenticate Token
     */
    async authenticateTokenApiV1IamAuthAuthenticateTokenPost(requestParameters: AuthenticateTokenApiV1IamAuthAuthenticateTokenPostRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticateTokenResponse> {
        const response = await this.authenticateTokenApiV1IamAuthAuthenticateTokenPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Configure SSO (SAML) settings for an organisation.  User must have ADMIN permission for the organisation.  Supported sign_on_method values: - \"password\": Standard password-based authentication - \"SAML 2.0\": SAML 2.0 SSO authentication  For SAML 2.0, the sign_on_config should include: - idp_entity_id: Identity Provider Entity ID - idp_sso_url: Identity Provider SSO URL - idp_x509_cert: Identity Provider X.509 certificate - sp_entity_id: Service Provider Entity ID (your application) - sp_acs_url: Service Provider Assertion Consumer Service URL - attribute_mapping: Mapping of SAML attributes to user fields
     * Configure Organisation Sso
     */
    async configureOrganisationSsoApiV1IamOrganisationsOrganisationIdSsoConfigPutRaw(requestParameters: ConfigureOrganisationSsoApiV1IamOrganisationsOrganisationIdSsoConfigPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SAMLConfigResponse>> {
        if (requestParameters['organisationId'] == null) {
            throw new runtime.RequiredError(
                'organisationId',
                'Required parameter "organisationId" was null or undefined when calling configureOrganisationSsoApiV1IamOrganisationsOrganisationIdSsoConfigPut().'
            );
        }

        if (requestParameters['sAMLConfigRequest'] == null) {
            throw new runtime.RequiredError(
                'sAMLConfigRequest',
                'Required parameter "sAMLConfigRequest" was null or undefined when calling configureOrganisationSsoApiV1IamOrganisationsOrganisationIdSsoConfigPut().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/organisations/{organisation_id}/sso-config`;
        urlPath = urlPath.replace(`{${"organisation_id"}}`, encodeURIComponent(String(requestParameters['organisationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SAMLConfigRequestToJSON(requestParameters['sAMLConfigRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SAMLConfigResponseFromJSON(jsonValue));
    }

    /**
     * Configure SSO (SAML) settings for an organisation.  User must have ADMIN permission for the organisation.  Supported sign_on_method values: - \"password\": Standard password-based authentication - \"SAML 2.0\": SAML 2.0 SSO authentication  For SAML 2.0, the sign_on_config should include: - idp_entity_id: Identity Provider Entity ID - idp_sso_url: Identity Provider SSO URL - idp_x509_cert: Identity Provider X.509 certificate - sp_entity_id: Service Provider Entity ID (your application) - sp_acs_url: Service Provider Assertion Consumer Service URL - attribute_mapping: Mapping of SAML attributes to user fields
     * Configure Organisation Sso
     */
    async configureOrganisationSsoApiV1IamOrganisationsOrganisationIdSsoConfigPut(requestParameters: ConfigureOrganisationSsoApiV1IamOrganisationsOrganisationIdSsoConfigPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SAMLConfigResponse> {
        const response = await this.configureOrganisationSsoApiV1IamOrganisationsOrganisationIdSsoConfigPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new API token for programmatic access to a specific project.  User must have MANAGE_TOKENS permission in the project or its organisation.
     * Create Chatbot Extension Token
     */
    async createChatbotExtensionTokenApiV1IamChatbotExtensionTokenPostRaw(requestParameters: CreateChatbotExtensionTokenApiV1IamChatbotExtensionTokenPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateChatbotExtensionTokenResponse>> {
        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/chatbot-extension/token`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateChatbotExtensionTokenResponseFromJSON(jsonValue));
    }

    /**
     * Create a new API token for programmatic access to a specific project.  User must have MANAGE_TOKENS permission in the project or its organisation.
     * Create Chatbot Extension Token
     */
    async createChatbotExtensionTokenApiV1IamChatbotExtensionTokenPost(requestParameters: CreateChatbotExtensionTokenApiV1IamChatbotExtensionTokenPostRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateChatbotExtensionTokenResponse> {
        const response = await this.createChatbotExtensionTokenApiV1IamChatbotExtensionTokenPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new organisation.  User must have CREATE_ORGANISATION permission. User becomes the organisation admin upon creation.
     * Create Organisation
     */
    async createOrganisationApiV1IamOrganisationsPostRaw(requestParameters: CreateOrganisationApiV1IamOrganisationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OrganisationResponse>> {
        if (requestParameters['createOrganisationRequest'] == null) {
            throw new runtime.RequiredError(
                'createOrganisationRequest',
                'Required parameter "createOrganisationRequest" was null or undefined when calling createOrganisationApiV1IamOrganisationsPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/organisations/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateOrganisationRequestToJSON(requestParameters['createOrganisationRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrganisationResponseFromJSON(jsonValue));
    }

    /**
     * Create a new organisation.  User must have CREATE_ORGANISATION permission. User becomes the organisation admin upon creation.
     * Create Organisation
     */
    async createOrganisationApiV1IamOrganisationsPost(requestParameters: CreateOrganisationApiV1IamOrganisationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OrganisationResponse> {
        const response = await this.createOrganisationApiV1IamOrganisationsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new project within an organisation.  User must have CREATE_PROJECTS permission in the organisation. User becomes the project admin upon creation.
     * Create Project
     */
    async createProjectApiV1IamProjectsPostRaw(requestParameters: CreateProjectApiV1IamProjectsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProjectResponse>> {
        if (requestParameters['createProjectRequest'] == null) {
            throw new runtime.RequiredError(
                'createProjectRequest',
                'Required parameter "createProjectRequest" was null or undefined when calling createProjectApiV1IamProjectsPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/projects/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateProjectRequestToJSON(requestParameters['createProjectRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectResponseFromJSON(jsonValue));
    }

    /**
     * Create a new project within an organisation.  User must have CREATE_PROJECTS permission in the organisation. User becomes the project admin upon creation.
     * Create Project
     */
    async createProjectApiV1IamProjectsPost(requestParameters: CreateProjectApiV1IamProjectsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProjectResponse> {
        const response = await this.createProjectApiV1IamProjectsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new API token for programmatic access to a specific project.  User must have MANAGE_TOKENS permission in the project or its organisation.
     * Create Token
     */
    async createTokenApiV1IamTokensPostRaw(requestParameters: CreateTokenApiV1IamTokensPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTokenResponse>> {
        if (requestParameters['createTokenRequest'] == null) {
            throw new runtime.RequiredError(
                'createTokenRequest',
                'Required parameter "createTokenRequest" was null or undefined when calling createTokenApiV1IamTokensPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/tokens/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTokenRequestToJSON(requestParameters['createTokenRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTokenResponseFromJSON(jsonValue));
    }

    /**
     * Create a new API token for programmatic access to a specific project.  User must have MANAGE_TOKENS permission in the project or its organisation.
     * Create Token
     */
    async createTokenApiV1IamTokensPost(requestParameters: CreateTokenApiV1IamTokensPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTokenResponse> {
        const response = await this.createTokenApiV1IamTokensPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deactivate the current user\'s account.  Only the user can deactivate their own account. This sets the user\'s is_active flag to False.
     * Deactivate Current User
     */
    async deactivateCurrentUserApiV1IamUsersMeDeleteRaw(requestParameters: DeactivateCurrentUserApiV1IamUsersMeDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/users/me`;

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Deactivate the current user\'s account.  Only the user can deactivate their own account. This sets the user\'s is_active flag to False.
     * Deactivate Current User
     */
    async deactivateCurrentUserApiV1IamUsersMeDelete(requestParameters: DeactivateCurrentUserApiV1IamUsersMeDeleteRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deactivateCurrentUserApiV1IamUsersMeDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an organisation.  User must have DELETE permission for the organisation. This now performs a hard delete, removing the organisation and all dependent data.
     * Delete Organisation Endpoint
     */
    async deleteOrganisationEndpointApiV1IamOrganisationsOrganisationIdDeleteRaw(requestParameters: DeleteOrganisationEndpointApiV1IamOrganisationsOrganisationIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['organisationId'] == null) {
            throw new runtime.RequiredError(
                'organisationId',
                'Required parameter "organisationId" was null or undefined when calling deleteOrganisationEndpointApiV1IamOrganisationsOrganisationIdDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/organisations/{organisation_id}`;
        urlPath = urlPath.replace(`{${"organisation_id"}}`, encodeURIComponent(String(requestParameters['organisationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Delete an organisation.  User must have DELETE permission for the organisation. This now performs a hard delete, removing the organisation and all dependent data.
     * Delete Organisation Endpoint
     */
    async deleteOrganisationEndpointApiV1IamOrganisationsOrganisationIdDelete(requestParameters: DeleteOrganisationEndpointApiV1IamOrganisationsOrganisationIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteOrganisationEndpointApiV1IamOrganisationsOrganisationIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a project.  User must have DELETE permission for the project or organisation. This permanently deletes the project from the database.
     * Delete Project
     */
    async deleteProjectApiV1IamProjectsProjectIdDeleteRaw(requestParameters: DeleteProjectApiV1IamProjectsProjectIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling deleteProjectApiV1IamProjectsProjectIdDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/projects/{project_id}`;
        urlPath = urlPath.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters['projectId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Delete a project.  User must have DELETE permission for the project or organisation. This permanently deletes the project from the database.
     * Delete Project
     */
    async deleteProjectApiV1IamProjectsProjectIdDelete(requestParameters: DeleteProjectApiV1IamProjectsProjectIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteProjectApiV1IamProjectsProjectIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an API token.  User must own the token or have MANAGE_TOKENS permission in the project.
     * Delete Token
     */
    async deleteTokenApiV1IamTokensTokenIdDeleteRaw(requestParameters: DeleteTokenApiV1IamTokensTokenIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling deleteTokenApiV1IamTokensTokenIdDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/tokens/{token_id}`;
        urlPath = urlPath.replace(`{${"token_id"}}`, encodeURIComponent(String(requestParameters['tokenId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Delete an API token.  User must own the token or have MANAGE_TOKENS permission in the project.
     * Delete Token
     */
    async deleteTokenApiV1IamTokensTokenIdDelete(requestParameters: DeleteTokenApiV1IamTokensTokenIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteTokenApiV1IamTokensTokenIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get current user\'s profile information.
     * Get Current User Profile
     */
    async getCurrentUserProfileApiV1IamUsersMeGetRaw(requestParameters: GetCurrentUserProfileApiV1IamUsersMeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/users/me`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Get current user\'s profile information.
     * Get Current User Profile
     */
    async getCurrentUserProfileApiV1IamUsersMeGet(requestParameters: GetCurrentUserProfileApiV1IamUsersMeGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.getCurrentUserProfileApiV1IamUsersMeGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get details of a specific organisation.  User must be a member of the organisation.
     * Get Organisation
     */
    async getOrganisationApiV1IamOrganisationsOrganisationIdGetRaw(requestParameters: GetOrganisationApiV1IamOrganisationsOrganisationIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OrganisationResponse>> {
        if (requestParameters['organisationId'] == null) {
            throw new runtime.RequiredError(
                'organisationId',
                'Required parameter "organisationId" was null or undefined when calling getOrganisationApiV1IamOrganisationsOrganisationIdGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/organisations/{organisation_id}`;
        urlPath = urlPath.replace(`{${"organisation_id"}}`, encodeURIComponent(String(requestParameters['organisationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrganisationResponseFromJSON(jsonValue));
    }

    /**
     * Get details of a specific organisation.  User must be a member of the organisation.
     * Get Organisation
     */
    async getOrganisationApiV1IamOrganisationsOrganisationIdGet(requestParameters: GetOrganisationApiV1IamOrganisationsOrganisationIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OrganisationResponse> {
        const response = await this.getOrganisationApiV1IamOrganisationsOrganisationIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get SSO (SAML) configuration for an organisation.  User must have ADMIN permission for the organisation.
     * Get Organisation Sso Config
     */
    async getOrganisationSsoConfigApiV1IamOrganisationsOrganisationIdSsoConfigGetRaw(requestParameters: GetOrganisationSsoConfigApiV1IamOrganisationsOrganisationIdSsoConfigGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SAMLConfigResponse>> {
        if (requestParameters['organisationId'] == null) {
            throw new runtime.RequiredError(
                'organisationId',
                'Required parameter "organisationId" was null or undefined when calling getOrganisationSsoConfigApiV1IamOrganisationsOrganisationIdSsoConfigGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/organisations/{organisation_id}/sso-config`;
        urlPath = urlPath.replace(`{${"organisation_id"}}`, encodeURIComponent(String(requestParameters['organisationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SAMLConfigResponseFromJSON(jsonValue));
    }

    /**
     * Get SSO (SAML) configuration for an organisation.  User must have ADMIN permission for the organisation.
     * Get Organisation Sso Config
     */
    async getOrganisationSsoConfigApiV1IamOrganisationsOrganisationIdSsoConfigGet(requestParameters: GetOrganisationSsoConfigApiV1IamOrganisationsOrganisationIdSsoConfigGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SAMLConfigResponse> {
        const response = await this.getOrganisationSsoConfigApiV1IamOrganisationsOrganisationIdSsoConfigGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get details of a specific project.  User must be a member of the project or its organisation.
     * Get Project
     */
    async getProjectApiV1IamProjectsProjectIdGetRaw(requestParameters: GetProjectApiV1IamProjectsProjectIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProjectResponse>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling getProjectApiV1IamProjectsProjectIdGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/projects/{project_id}`;
        urlPath = urlPath.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters['projectId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectResponseFromJSON(jsonValue));
    }

    /**
     * Get details of a specific project.  User must be a member of the project or its organisation.
     * Get Project
     */
    async getProjectApiV1IamProjectsProjectIdGet(requestParameters: GetProjectApiV1IamProjectsProjectIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProjectResponse> {
        const response = await this.getProjectApiV1IamProjectsProjectIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get details of a specific API token.  User must own the token or have VIEW_TOKENS permission in the project.
     * Get Token
     */
    async getTokenApiV1IamTokensTokenIdGetRaw(requestParameters: GetTokenApiV1IamTokensTokenIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenResponse>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling getTokenApiV1IamTokensTokenIdGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/tokens/{token_id}`;
        urlPath = urlPath.replace(`{${"token_id"}}`, encodeURIComponent(String(requestParameters['tokenId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenResponseFromJSON(jsonValue));
    }

    /**
     * Get details of a specific API token.  User must own the token or have VIEW_TOKENS permission in the project.
     * Get Token
     */
    async getTokenApiV1IamTokensTokenIdGet(requestParameters: GetTokenApiV1IamTokensTokenIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenResponse> {
        const response = await this.getTokenApiV1IamTokensTokenIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Impersonate a user.  This endpoint does not require authentication.
     * Impersonate
     */
    async impersonateApiV1IamUsersImpersonatePostRaw(requestParameters: ImpersonateApiV1IamUsersImpersonatePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['impersonateRequest'] == null) {
            throw new runtime.RequiredError(
                'impersonateRequest',
                'Required parameter "impersonateRequest" was null or undefined when calling impersonateApiV1IamUsersImpersonatePost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/users/impersonate`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ImpersonateRequestToJSON(requestParameters['impersonateRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Impersonate a user.  This endpoint does not require authentication.
     * Impersonate
     */
    async impersonateApiV1IamUsersImpersonatePost(requestParameters: ImpersonateApiV1IamUsersImpersonatePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.impersonateApiV1IamUsersImpersonatePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Invalidate User Cache
     */
    async invalidateUserCacheApiV1IamUsersInvalidateCachePostRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/users/invalidate-cache`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Invalidate User Cache
     */
    async invalidateUserCacheApiV1IamUsersInvalidateCachePost(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.invalidateUserCacheApiV1IamUsersInvalidateCachePostRaw(initOverrides);
        return await response.value();
    }

    /**
     * List core fixed roles. Optionally filter by `scope` (organisation | project | user).
     * List Core Roles
     */
    async listCoreRolesApiV1IamRolesGetRaw(requestParameters: ListCoreRolesApiV1IamRolesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoleListResponse>> {
        const queryParameters: any = {};

        if (requestParameters['scope'] != null) {
            queryParameters['scope'] = requestParameters['scope'];
        }

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/roles/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleListResponseFromJSON(jsonValue));
    }

    /**
     * List core fixed roles. Optionally filter by `scope` (organisation | project | user).
     * List Core Roles
     */
    async listCoreRolesApiV1IamRolesGet(requestParameters: ListCoreRolesApiV1IamRolesGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoleListResponse> {
        const response = await this.listCoreRolesApiV1IamRolesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List invitations for organisations the user has access to.  Can filter by organisation and status.
     * List Invitations
     */
    async listInvitationsApiV1IamInvitationsGetRaw(requestParameters: ListInvitationsApiV1IamInvitationsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InvitationListResponse>> {
        const queryParameters: any = {};

        if (requestParameters['organisationId'] != null) {
            queryParameters['organisation_id'] = requestParameters['organisationId'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/invitations/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InvitationListResponseFromJSON(jsonValue));
    }

    /**
     * List invitations for organisations the user has access to.  Can filter by organisation and status.
     * List Invitations
     */
    async listInvitationsApiV1IamInvitationsGet(requestParameters: ListInvitationsApiV1IamInvitationsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InvitationListResponse> {
        const response = await this.listInvitationsApiV1IamInvitationsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List users in an organisation.  User must have VIEW_USERS permission in the organisation.
     * List Organisation Users
     */
    async listOrganisationUsersApiV1IamUsersOrganisationsOrganisationIdGetRaw(requestParameters: ListOrganisationUsersApiV1IamUsersOrganisationsOrganisationIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserListResponse>> {
        if (requestParameters['organisationId'] == null) {
            throw new runtime.RequiredError(
                'organisationId',
                'Required parameter "organisationId" was null or undefined when calling listOrganisationUsersApiV1IamUsersOrganisationsOrganisationIdGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/users/organisations/{organisation_id}`;
        urlPath = urlPath.replace(`{${"organisation_id"}}`, encodeURIComponent(String(requestParameters['organisationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserListResponseFromJSON(jsonValue));
    }

    /**
     * List users in an organisation.  User must have VIEW_USERS permission in the organisation.
     * List Organisation Users
     */
    async listOrganisationUsersApiV1IamUsersOrganisationsOrganisationIdGet(requestParameters: ListOrganisationUsersApiV1IamUsersOrganisationsOrganisationIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserListResponse> {
        const response = await this.listOrganisationUsersApiV1IamUsersOrganisationsOrganisationIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List users in a project.  User must have VIEW_USERS permission in the project or organisation.
     * List Project Users
     */
    async listProjectUsersApiV1IamUsersProjectsProjectIdGetRaw(requestParameters: ListProjectUsersApiV1IamUsersProjectsProjectIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserListResponse>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling listProjectUsersApiV1IamUsersProjectsProjectIdGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/users/projects/{project_id}`;
        urlPath = urlPath.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters['projectId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserListResponseFromJSON(jsonValue));
    }

    /**
     * List users in a project.  User must have VIEW_USERS permission in the project or organisation.
     * List Project Users
     */
    async listProjectUsersApiV1IamUsersProjectsProjectIdGet(requestParameters: ListProjectUsersApiV1IamUsersProjectsProjectIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserListResponse> {
        const response = await this.listProjectUsersApiV1IamUsersProjectsProjectIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all roles assigned to an API token.  User must have VIEW_TOKENS permission in the token\'s project.
     * List Token Roles
     */
    async listTokenRolesApiV1IamTokensTokenIdRolesGetRaw(requestParameters: ListTokenRolesApiV1IamTokensTokenIdRolesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TokenRoleResponse>>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling listTokenRolesApiV1IamTokensTokenIdRolesGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/tokens/{token_id}/roles`;
        urlPath = urlPath.replace(`{${"token_id"}}`, encodeURIComponent(String(requestParameters['tokenId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenRoleResponseFromJSON));
    }

    /**
     * List all roles assigned to an API token.  User must have VIEW_TOKENS permission in the token\'s project.
     * List Token Roles
     */
    async listTokenRolesApiV1IamTokensTokenIdRolesGet(requestParameters: ListTokenRolesApiV1IamTokensTokenIdRolesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TokenRoleResponse>> {
        const response = await this.listTokenRolesApiV1IamTokensTokenIdRolesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List API tokens for the current user in a specific project.  User must have VIEW_TOKENS permission in the project.
     * List Tokens
     */
    async listTokensApiV1IamTokensGetRaw(requestParameters: ListTokensApiV1IamTokensGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenListResponse>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling listTokensApiV1IamTokensGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['projectId'] != null) {
            queryParameters['project_id'] = requestParameters['projectId'];
        }

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/tokens/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenListResponseFromJSON(jsonValue));
    }

    /**
     * List API tokens for the current user in a specific project.  User must have VIEW_TOKENS permission in the project.
     * List Tokens
     */
    async listTokensApiV1IamTokensGet(requestParameters: ListTokensApiV1IamTokensGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenListResponse> {
        const response = await this.listTokensApiV1IamTokensGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List organisations that the current user is a member of.
     * List User Organisations
     */
    async listUserOrganisationsApiV1IamOrganisationsGetRaw(requestParameters: ListUserOrganisationsApiV1IamOrganisationsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OrganisationListResponse>> {
        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/organisations/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrganisationListResponseFromJSON(jsonValue));
    }

    /**
     * List organisations that the current user is a member of.
     * List User Organisations
     */
    async listUserOrganisationsApiV1IamOrganisationsGet(requestParameters: ListUserOrganisationsApiV1IamOrganisationsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OrganisationListResponse> {
        const response = await this.listUserOrganisationsApiV1IamOrganisationsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List projects that the current user is a member of. Optionally filter by organisation.
     * List User Projects
     */
    async listUserProjectsApiV1IamProjectsGetRaw(requestParameters: ListUserProjectsApiV1IamProjectsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProjectListResponse>> {
        const queryParameters: any = {};

        if (requestParameters['organisationId'] != null) {
            queryParameters['organisation_id'] = requestParameters['organisationId'];
        }

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/projects/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectListResponseFromJSON(jsonValue));
    }

    /**
     * List projects that the current user is a member of. Optionally filter by organisation.
     * List User Projects
     */
    async listUserProjectsApiV1IamProjectsGet(requestParameters: ListUserProjectsApiV1IamProjectsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProjectListResponse> {
        const response = await this.listUserProjectsApiV1IamProjectsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all roles assigned to a user.  User can view their own roles or must have VIEW_USERS permission in relevant organisations.
     * List User Roles
     */
    async listUserRolesApiV1IamUsersUserIdRolesGetRaw(requestParameters: ListUserRolesApiV1IamUsersUserIdRolesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserRoleResponse>>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling listUserRolesApiV1IamUsersUserIdRolesGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['scopeType'] != null) {
            queryParameters['scope_type'] = requestParameters['scopeType'];
        }

        if (requestParameters['scopeId'] != null) {
            queryParameters['scope_id'] = requestParameters['scopeId'];
        }

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/users/{user_id}/roles`;
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserRoleResponseFromJSON));
    }

    /**
     * List all roles assigned to a user.  User can view their own roles or must have VIEW_USERS permission in relevant organisations.
     * List User Roles
     */
    async listUserRolesApiV1IamUsersUserIdRolesGet(requestParameters: ListUserRolesApiV1IamUsersUserIdRolesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserRoleResponse>> {
        const response = await this.listUserRolesApiV1IamUsersUserIdRolesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Authenticate user with email and password and return JWT token.  This endpoint does not require authentication.
     * Login
     */
    async loginApiV1IamUsersLoginPostRaw(requestParameters: LoginApiV1IamUsersLoginPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoginResponse>> {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError(
                'loginRequest',
                'Required parameter "loginRequest" was null or undefined when calling loginApiV1IamUsersLoginPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/v1/iam/users/login`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoginResponseFromJSON(jsonValue));
    }

    /**
     * Authenticate user with email and password and return JWT token.  This endpoint does not require authentication.
     * Login
     */
    async loginApiV1IamUsersLoginPost(requestParameters: LoginApiV1IamUsersLoginPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoginResponse> {
        const response = await this.loginApiV1IamUsersLoginPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a role assignment from an API token.  User must have MANAGE_TOKENS permission in the token\'s project. User must also have ASSIGN_ROLES permission in the relevant scope.
     * Remove Token Role
     */
    async removeTokenRoleApiV1IamTokensTokenIdRolesTokenRoleIdDeleteRaw(requestParameters: RemoveTokenRoleApiV1IamTokensTokenIdRolesTokenRoleIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling removeTokenRoleApiV1IamTokensTokenIdRolesTokenRoleIdDelete().'
            );
        }

        if (requestParameters['tokenRoleId'] == null) {
            throw new runtime.RequiredError(
                'tokenRoleId',
                'Required parameter "tokenRoleId" was null or undefined when calling removeTokenRoleApiV1IamTokensTokenIdRolesTokenRoleIdDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/tokens/{token_id}/roles/{token_role_id}`;
        urlPath = urlPath.replace(`{${"token_id"}}`, encodeURIComponent(String(requestParameters['tokenId'])));
        urlPath = urlPath.replace(`{${"token_role_id"}}`, encodeURIComponent(String(requestParameters['tokenRoleId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Remove a role assignment from an API token.  User must have MANAGE_TOKENS permission in the token\'s project. User must also have ASSIGN_ROLES permission in the relevant scope.
     * Remove Token Role
     */
    async removeTokenRoleApiV1IamTokensTokenIdRolesTokenRoleIdDelete(requestParameters: RemoveTokenRoleApiV1IamTokensTokenIdRolesTokenRoleIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.removeTokenRoleApiV1IamTokensTokenIdRolesTokenRoleIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a user from an organisation.  User must have REMOVE_USERS permission in the organisation. Cannot remove yourself.
     * Remove User From Organisation
     */
    async removeUserFromOrganisationApiV1IamUsersOrganisationsOrganisationIdUsersUserIdDeleteRaw(requestParameters: RemoveUserFromOrganisationApiV1IamUsersOrganisationsOrganisationIdUsersUserIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['organisationId'] == null) {
            throw new runtime.RequiredError(
                'organisationId',
                'Required parameter "organisationId" was null or undefined when calling removeUserFromOrganisationApiV1IamUsersOrganisationsOrganisationIdUsersUserIdDelete().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling removeUserFromOrganisationApiV1IamUsersOrganisationsOrganisationIdUsersUserIdDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/users/organisations/{organisation_id}/users/{user_id}`;
        urlPath = urlPath.replace(`{${"organisation_id"}}`, encodeURIComponent(String(requestParameters['organisationId'])));
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Remove a user from an organisation.  User must have REMOVE_USERS permission in the organisation. Cannot remove yourself.
     * Remove User From Organisation
     */
    async removeUserFromOrganisationApiV1IamUsersOrganisationsOrganisationIdUsersUserIdDelete(requestParameters: RemoveUserFromOrganisationApiV1IamUsersOrganisationsOrganisationIdUsersUserIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.removeUserFromOrganisationApiV1IamUsersOrganisationsOrganisationIdUsersUserIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a user from a project.  User must have REMOVE_USERS permission in the project or organisation. Cannot remove yourself if you\'re the only admin.
     * Remove User From Project
     */
    async removeUserFromProjectApiV1IamUsersProjectsProjectIdUsersUserIdDeleteRaw(requestParameters: RemoveUserFromProjectApiV1IamUsersProjectsProjectIdUsersUserIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling removeUserFromProjectApiV1IamUsersProjectsProjectIdUsersUserIdDelete().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling removeUserFromProjectApiV1IamUsersProjectsProjectIdUsersUserIdDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/users/projects/{project_id}/users/{user_id}`;
        urlPath = urlPath.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters['projectId'])));
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Remove a user from a project.  User must have REMOVE_USERS permission in the project or organisation. Cannot remove yourself if you\'re the only admin.
     * Remove User From Project
     */
    async removeUserFromProjectApiV1IamUsersProjectsProjectIdUsersUserIdDelete(requestParameters: RemoveUserFromProjectApiV1IamUsersProjectsProjectIdUsersUserIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.removeUserFromProjectApiV1IamUsersProjectsProjectIdUsersUserIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a role assignment from a user.  User must have MANAGE_USER_ROLES permission in the organisation. User must also have ASSIGN_ROLES permission in the relevant scope.
     * Remove User Role
     */
    async removeUserRoleApiV1IamUsersUserIdRolesUserRoleIdDeleteRaw(requestParameters: RemoveUserRoleApiV1IamUsersUserIdRolesUserRoleIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling removeUserRoleApiV1IamUsersUserIdRolesUserRoleIdDelete().'
            );
        }

        if (requestParameters['userRoleId'] == null) {
            throw new runtime.RequiredError(
                'userRoleId',
                'Required parameter "userRoleId" was null or undefined when calling removeUserRoleApiV1IamUsersUserIdRolesUserRoleIdDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/users/{user_id}/roles/{user_role_id}`;
        urlPath = urlPath.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId'])));
        urlPath = urlPath.replace(`{${"user_role_id"}}`, encodeURIComponent(String(requestParameters['userRoleId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Remove a role assignment from a user.  User must have MANAGE_USER_ROLES permission in the organisation. User must also have ASSIGN_ROLES permission in the relevant scope.
     * Remove User Role
     */
    async removeUserRoleApiV1IamUsersUserIdRolesUserRoleIdDelete(requestParameters: RemoveUserRoleApiV1IamUsersUserIdRolesUserRoleIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.removeUserRoleApiV1IamUsersUserIdRolesUserRoleIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Request a password reset. If the user exists, send a reset email. Always return success to avoid email enumeration.
     * Request Password Reset
     */
    async requestPasswordResetApiV1IamUsersPasswordResetRequestPostRaw(requestParameters: RequestPasswordResetApiV1IamUsersPasswordResetRequestPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['passwordResetRequest'] == null) {
            throw new runtime.RequiredError(
                'passwordResetRequest',
                'Required parameter "passwordResetRequest" was null or undefined when calling requestPasswordResetApiV1IamUsersPasswordResetRequestPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/v1/iam/users/password/reset-request`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PasswordResetRequestToJSON(requestParameters['passwordResetRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Request a password reset. If the user exists, send a reset email. Always return success to avoid email enumeration.
     * Request Password Reset
     */
    async requestPasswordResetApiV1IamUsersPasswordResetRequestPost(requestParameters: RequestPasswordResetApiV1IamUsersPasswordResetRequestPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.requestPasswordResetApiV1IamUsersPasswordResetRequestPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reset password using token from email and new password from client.
     * Reset Password
     */
    async resetPasswordApiV1IamUsersPasswordResetPostRaw(requestParameters: ResetPasswordApiV1IamUsersPasswordResetPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['passwordResetConfirmRequest'] == null) {
            throw new runtime.RequiredError(
                'passwordResetConfirmRequest',
                'Required parameter "passwordResetConfirmRequest" was null or undefined when calling resetPasswordApiV1IamUsersPasswordResetPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/v1/iam/users/password/reset`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PasswordResetConfirmRequestToJSON(requestParameters['passwordResetConfirmRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Reset password using token from email and new password from client.
     * Reset Password
     */
    async resetPasswordApiV1IamUsersPasswordResetPost(requestParameters: ResetPasswordApiV1IamUsersPasswordResetPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.resetPasswordApiV1IamUsersPasswordResetPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Accept or reject an organisation invitation.  If accepted, add user to organisation with specified roles. If rejected, mark invitation as rejected.
     * Respond To Invitation
     */
    async respondToInvitationApiV1IamInvitationsInvitationIdDecisionPostRaw(requestParameters: RespondToInvitationApiV1IamInvitationsInvitationIdDecisionPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['invitationId'] == null) {
            throw new runtime.RequiredError(
                'invitationId',
                'Required parameter "invitationId" was null or undefined when calling respondToInvitationApiV1IamInvitationsInvitationIdDecisionPost().'
            );
        }

        if (requestParameters['decision'] == null) {
            throw new runtime.RequiredError(
                'decision',
                'Required parameter "decision" was null or undefined when calling respondToInvitationApiV1IamInvitationsInvitationIdDecisionPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/invitations/{invitation_id}/{decision}`;
        urlPath = urlPath.replace(`{${"invitation_id"}}`, encodeURIComponent(String(requestParameters['invitationId'])));
        urlPath = urlPath.replace(`{${"decision"}}`, encodeURIComponent(String(requestParameters['decision'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Accept or reject an organisation invitation.  If accepted, add user to organisation with specified roles. If rejected, mark invitation as rejected.
     * Respond To Invitation
     */
    async respondToInvitationApiV1IamInvitationsInvitationIdDecisionPost(requestParameters: RespondToInvitationApiV1IamInvitationsInvitationIdDecisionPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.respondToInvitationApiV1IamInvitationsInvitationIdDecisionPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Revoke a pending invitation.  User must have INVITE_USERS permission and be the inviter or org admin.
     * Revoke Invitation
     */
    async revokeInvitationApiV1IamInvitationsInvitationIdDeleteRaw(requestParameters: RevokeInvitationApiV1IamInvitationsInvitationIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<APIResponse>> {
        if (requestParameters['invitationId'] == null) {
            throw new runtime.RequiredError(
                'invitationId',
                'Required parameter "invitationId" was null or undefined when calling revokeInvitationApiV1IamInvitationsInvitationIdDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/invitations/{invitation_id}`;
        urlPath = urlPath.replace(`{${"invitation_id"}}`, encodeURIComponent(String(requestParameters['invitationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => APIResponseFromJSON(jsonValue));
    }

    /**
     * Revoke a pending invitation.  User must have INVITE_USERS permission and be the inviter or org admin.
     * Revoke Invitation
     */
    async revokeInvitationApiV1IamInvitationsInvitationIdDelete(requestParameters: RevokeInvitationApiV1IamInvitationsInvitationIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<APIResponse> {
        const response = await this.revokeInvitationApiV1IamInvitationsInvitationIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * SAML Assertion Consumer Service (ACS) endpoint.  This endpoint: 1. Receives and validates SAML assertion from IdP 2. Extracts user attributes 3. Creates/updates user in database 4. Issues JWT token 5. Redirects to frontend with token in URL fragment
     * Saml Acs
     */
    async samlAcsApiV1IamSamlAcsPostRaw(requestParameters: SamlAcsApiV1IamSamlAcsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['sAMLResponse'] == null) {
            throw new runtime.RequiredError(
                'sAMLResponse',
                'Required parameter "sAMLResponse" was null or undefined when calling samlAcsApiV1IamSamlAcsPost().'
            );
        }

        if (requestParameters['relayState'] == null) {
            throw new runtime.RequiredError(
                'relayState',
                'Required parameter "relayState" was null or undefined when calling samlAcsApiV1IamSamlAcsPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['sAMLResponse'] != null) {
            formParams.append('SAMLResponse', requestParameters['sAMLResponse'] as any);
        }

        if (requestParameters['relayState'] != null) {
            formParams.append('RelayState', requestParameters['relayState'] as any);
        }


        let urlPath = `/api/v1/iam/saml/acs`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * SAML Assertion Consumer Service (ACS) endpoint.  This endpoint: 1. Receives and validates SAML assertion from IdP 2. Extracts user attributes 3. Creates/updates user in database 4. Issues JWT token 5. Redirects to frontend with token in URL fragment
     * Saml Acs
     */
    async samlAcsApiV1IamSamlAcsPost(requestParameters: SamlAcsApiV1IamSamlAcsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.samlAcsApiV1IamSamlAcsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Initiate SAML authentication request.  This endpoint: 1. Receives user email from frontend 2. Determines the organisation (from existing user or email domain) 3. Initiates SAML AuthN request 4. Returns redirect URL for frontend to navigate to IdP  Returns JSON with: - redirect_url: URL to navigate to for IdP authentication - organisation_id: ID of the organisation for this SAML flow
     * Saml Login Request
     */
    async samlLoginRequestApiV1IamSamlLoginPostRaw(requestParameters: SamlLoginRequestApiV1IamSamlLoginPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['sAMLLoginRequest'] == null) {
            throw new runtime.RequiredError(
                'sAMLLoginRequest',
                'Required parameter "sAMLLoginRequest" was null or undefined when calling samlLoginRequestApiV1IamSamlLoginPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/v1/iam/saml/login`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SAMLLoginRequestToJSON(requestParameters['sAMLLoginRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Initiate SAML authentication request.  This endpoint: 1. Receives user email from frontend 2. Determines the organisation (from existing user or email domain) 3. Initiates SAML AuthN request 4. Returns redirect URL for frontend to navigate to IdP  Returns JSON with: - redirect_url: URL to navigate to for IdP authentication - organisation_id: ID of the organisation for this SAML flow
     * Saml Login Request
     */
    async samlLoginRequestApiV1IamSamlLoginPost(requestParameters: SamlLoginRequestApiV1IamSamlLoginPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.samlLoginRequestApiV1IamSamlLoginPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Send an invitation to join an organisation.  User must have INVITE_USERS permission in the organisation.
     * Send Invitation
     */
    async sendInvitationApiV1IamInvitationsPostRaw(requestParameters: SendInvitationApiV1IamInvitationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InvitationResponse>> {
        if (requestParameters['sendInvitationRequest'] == null) {
            throw new runtime.RequiredError(
                'sendInvitationRequest',
                'Required parameter "sendInvitationRequest" was null or undefined when calling sendInvitationApiV1IamInvitationsPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/invitations/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SendInvitationRequestToJSON(requestParameters['sendInvitationRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InvitationResponseFromJSON(jsonValue));
    }

    /**
     * Send an invitation to join an organisation.  User must have INVITE_USERS permission in the organisation.
     * Send Invitation
     */
    async sendInvitationApiV1IamInvitationsPost(requestParameters: SendInvitationApiV1IamInvitationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InvitationResponse> {
        const response = await this.sendInvitationApiV1IamInvitationsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a new user and check for pending invitations.  If the user has pending invitations, return invitation details. Otherwise, create the user with default permissions and return success.
     * Signup
     */
    async signupApiV1IamAuthSignupPostRaw(requestParameters: SignupApiV1IamAuthSignupPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SignUpResponse>> {
        if (requestParameters['signUpRequest'] == null) {
            throw new runtime.RequiredError(
                'signUpRequest',
                'Required parameter "signUpRequest" was null or undefined when calling signupApiV1IamAuthSignupPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/v1/iam/auth/signup`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SignUpRequestToJSON(requestParameters['signUpRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SignUpResponseFromJSON(jsonValue));
    }

    /**
     * Register a new user and check for pending invitations.  If the user has pending invitations, return invitation details. Otherwise, create the user with default permissions and return success.
     * Signup
     */
    async signupApiV1IamAuthSignupPost(requestParameters: SignupApiV1IamAuthSignupPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SignUpResponse> {
        const response = await this.signupApiV1IamAuthSignupPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a new user using a specific invitation.  - Validates that the invitation exists, is pending, and not expired - Uses the invitation email for the new account - Marks the user\'s email as verified automatically - Returns details for the used invitation only
     * Signup By Invitation
     */
    async signupByInvitationApiV1IamAuthSignupByInvitationPostRaw(requestParameters: SignupByInvitationApiV1IamAuthSignupByInvitationPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SignUpResponse>> {
        if (requestParameters['invitationSignUpRequest'] == null) {
            throw new runtime.RequiredError(
                'invitationSignUpRequest',
                'Required parameter "invitationSignUpRequest" was null or undefined when calling signupByInvitationApiV1IamAuthSignupByInvitationPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/v1/iam/auth/signup-by-invitation`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InvitationSignUpRequestToJSON(requestParameters['invitationSignUpRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SignUpResponseFromJSON(jsonValue));
    }

    /**
     * Register a new user using a specific invitation.  - Validates that the invitation exists, is pending, and not expired - Uses the invitation email for the new account - Marks the user\'s email as verified automatically - Returns details for the used invitation only
     * Signup By Invitation
     */
    async signupByInvitationApiV1IamAuthSignupByInvitationPost(requestParameters: SignupByInvitationApiV1IamAuthSignupByInvitationPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SignUpResponse> {
        const response = await this.signupByInvitationApiV1IamAuthSignupByInvitationPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update organisation details.  User must have MANAGE permission for the organisation.
     * Update Organisation
     */
    async updateOrganisationApiV1IamOrganisationsOrganisationIdPutRaw(requestParameters: UpdateOrganisationApiV1IamOrganisationsOrganisationIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OrganisationResponse>> {
        if (requestParameters['organisationId'] == null) {
            throw new runtime.RequiredError(
                'organisationId',
                'Required parameter "organisationId" was null or undefined when calling updateOrganisationApiV1IamOrganisationsOrganisationIdPut().'
            );
        }

        if (requestParameters['createOrganisationRequest'] == null) {
            throw new runtime.RequiredError(
                'createOrganisationRequest',
                'Required parameter "createOrganisationRequest" was null or undefined when calling updateOrganisationApiV1IamOrganisationsOrganisationIdPut().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/organisations/{organisation_id}`;
        urlPath = urlPath.replace(`{${"organisation_id"}}`, encodeURIComponent(String(requestParameters['organisationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CreateOrganisationRequestToJSON(requestParameters['createOrganisationRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrganisationResponseFromJSON(jsonValue));
    }

    /**
     * Update organisation details.  User must have MANAGE permission for the organisation.
     * Update Organisation
     */
    async updateOrganisationApiV1IamOrganisationsOrganisationIdPut(requestParameters: UpdateOrganisationApiV1IamOrganisationsOrganisationIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OrganisationResponse> {
        const response = await this.updateOrganisationApiV1IamOrganisationsOrganisationIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing project\'s details.  Requires project admin permissions. Ensures slug uniqueness within organisation. If slug is not provided but name is updated, a new slug is generated from the new name.
     * Update Project
     */
    async updateProjectApiV1IamProjectsProjectIdPutRaw(requestParameters: UpdateProjectApiV1IamProjectsProjectIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProjectResponse>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling updateProjectApiV1IamProjectsProjectIdPut().'
            );
        }

        if (requestParameters['updateProjectRequest'] == null) {
            throw new runtime.RequiredError(
                'updateProjectRequest',
                'Required parameter "updateProjectRequest" was null or undefined when calling updateProjectApiV1IamProjectsProjectIdPut().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/projects/{project_id}`;
        urlPath = urlPath.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters['projectId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateProjectRequestToJSON(requestParameters['updateProjectRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectResponseFromJSON(jsonValue));
    }

    /**
     * Update an existing project\'s details.  Requires project admin permissions. Ensures slug uniqueness within organisation. If slug is not provided but name is updated, a new slug is generated from the new name.
     * Update Project
     */
    async updateProjectApiV1IamProjectsProjectIdPut(requestParameters: UpdateProjectApiV1IamProjectsProjectIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProjectResponse> {
        const response = await this.updateProjectApiV1IamProjectsProjectIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an API token.  User must own the token or have MANAGE_TOKENS permission in the project.
     * Update Token
     */
    async updateTokenApiV1IamTokensTokenIdPutRaw(requestParameters: UpdateTokenApiV1IamTokensTokenIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenResponse>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling updateTokenApiV1IamTokensTokenIdPut().'
            );
        }

        if (requestParameters['updateTokenRequest'] == null) {
            throw new runtime.RequiredError(
                'updateTokenRequest',
                'Required parameter "updateTokenRequest" was null or undefined when calling updateTokenApiV1IamTokensTokenIdPut().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/iam/tokens/{token_id}`;
        urlPath = urlPath.replace(`{${"token_id"}}`, encodeURIComponent(String(requestParameters['tokenId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateTokenRequestToJSON(requestParameters['updateTokenRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenResponseFromJSON(jsonValue));
    }

    /**
     * Update an API token.  User must own the token or have MANAGE_TOKENS permission in the project.
     * Update Token
     */
    async updateTokenApiV1IamTokensTokenIdPut(requestParameters: UpdateTokenApiV1IamTokensTokenIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenResponse> {
        const response = await this.updateTokenApiV1IamTokensTokenIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Validate an invitation token and return invitation details.  Decodes the token to extract the invitation_id, then validates status and expiry. Invitee can view; otherwise requires org admin permissions.
     * Validate Invitation Token
     */
    async validateInvitationTokenApiV1IamInvitationsValidateGetRaw(requestParameters: ValidateInvitationTokenApiV1IamInvitationsValidateGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InvitationResponse>> {
        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling validateInvitationTokenApiV1IamInvitationsValidateGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['token'] != null) {
            queryParameters['token'] = requestParameters['token'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/v1/iam/invitations/validate`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InvitationResponseFromJSON(jsonValue));
    }

    /**
     * Validate an invitation token and return invitation details.  Decodes the token to extract the invitation_id, then validates status and expiry. Invitee can view; otherwise requires org admin permissions.
     * Validate Invitation Token
     */
    async validateInvitationTokenApiV1IamInvitationsValidateGet(requestParameters: ValidateInvitationTokenApiV1IamInvitationsValidateGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InvitationResponse> {
        const response = await this.validateInvitationTokenApiV1IamInvitationsValidateGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Verify user email using a signed token sent via email.  - Decodes token to extract user_email - Validates token expiration and signature - Marks user as verified if not already
     * Verify Email
     */
    async verifyEmailApiV1IamAuthVerifyGetRaw(requestParameters: VerifyEmailApiV1IamAuthVerifyGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling verifyEmailApiV1IamAuthVerifyGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['token'] != null) {
            queryParameters['token'] = requestParameters['token'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/v1/iam/auth/verify`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Verify user email using a signed token sent via email.  - Decodes token to extract user_email - Validates token expiration and signature - Marks user as verified if not already
     * Verify Email
     */
    async verifyEmailApiV1IamAuthVerifyGet(requestParameters: VerifyEmailApiV1IamAuthVerifyGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.verifyEmailApiV1IamAuthVerifyGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
