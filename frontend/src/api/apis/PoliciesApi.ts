/* tslint:disable */
/* eslint-disable */
/**
 * Overmind Backend
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreatePolicyVersionRequest,
  HTTPValidationError,
  MCPToolsRequest,
  OrganisationPolicyResponse,
  PolicyVersionListResponse,
  PolicyVersionResponse,
  VerifyChatbotRequest,
} from '../models/index';
import {
    CreatePolicyVersionRequestFromJSON,
    CreatePolicyVersionRequestToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    MCPToolsRequestFromJSON,
    MCPToolsRequestToJSON,
    OrganisationPolicyResponseFromJSON,
    OrganisationPolicyResponseToJSON,
    PolicyVersionListResponseFromJSON,
    PolicyVersionListResponseToJSON,
    PolicyVersionResponseFromJSON,
    PolicyVersionResponseToJSON,
    VerifyChatbotRequestFromJSON,
    VerifyChatbotRequestToJSON,
} from '../models/index';

export interface CreatePolicyVersionApiV1PoliciesVersionsPostRequest {
    createPolicyVersionRequest: CreatePolicyVersionRequest;
    useCache?: boolean;
}

export interface FetchMcpToolsApiV1PoliciesFetchMcpToolsPostRequest {
    mCPToolsRequest: MCPToolsRequest;
    useCache?: boolean;
}

export interface GetOrganisationPolicyApiV1PoliciesOrganisationOrganisationIdGetRequest {
    organisationId: string;
    useCache?: boolean;
}

export interface ListPolicyVersionsApiV1PoliciesVersionsGetRequest {
    organisationId: string;
    limit?: number;
    useCache?: boolean;
}

export interface VerifyChatbotApiV1PoliciesVerifyChatbotPostRequest {
    verifyChatbotRequest: VerifyChatbotRequest;
    useCache?: boolean;
}

/**
 * 
 */
export class PoliciesApi extends runtime.BaseAPI {

    /**
     * Create a new policy version for an organisation. Automatically sets previous_policy_id to the current organisation policy (if present) and updates OrganisationPolicy to point to the newly created version.  Empty policies (llm_policy empty dict, and mcp_policy/chatbot_policy None) are allowed.
     * Create Policy Version
     */
    async createPolicyVersionApiV1PoliciesVersionsPostRaw(requestParameters: CreatePolicyVersionApiV1PoliciesVersionsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PolicyVersionResponse>> {
        if (requestParameters['createPolicyVersionRequest'] == null) {
            throw new runtime.RequiredError(
                'createPolicyVersionRequest',
                'Required parameter "createPolicyVersionRequest" was null or undefined when calling createPolicyVersionApiV1PoliciesVersionsPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/policies/versions`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreatePolicyVersionRequestToJSON(requestParameters['createPolicyVersionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PolicyVersionResponseFromJSON(jsonValue));
    }

    /**
     * Create a new policy version for an organisation. Automatically sets previous_policy_id to the current organisation policy (if present) and updates OrganisationPolicy to point to the newly created version.  Empty policies (llm_policy empty dict, and mcp_policy/chatbot_policy None) are allowed.
     * Create Policy Version
     */
    async createPolicyVersionApiV1PoliciesVersionsPost(requestParameters: CreatePolicyVersionApiV1PoliciesVersionsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PolicyVersionResponse> {
        const response = await this.createPolicyVersionApiV1PoliciesVersionsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch available tools from an MCP server using sequential requests.  Makes three requests in sequence: 1. initialize - establish session and negotiate protocol 2. notifications/initialized - signal ready for operations 3. tools/list - get the actual tools list
     * Fetch Mcp Tools
     */
    async fetchMcpToolsApiV1PoliciesFetchMcpToolsPostRaw(requestParameters: FetchMcpToolsApiV1PoliciesFetchMcpToolsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: any; }>> {
        if (requestParameters['mCPToolsRequest'] == null) {
            throw new runtime.RequiredError(
                'mCPToolsRequest',
                'Required parameter "mCPToolsRequest" was null or undefined when calling fetchMcpToolsApiV1PoliciesFetchMcpToolsPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/policies/fetch_mcp_tools`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MCPToolsRequestToJSON(requestParameters['mCPToolsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetch available tools from an MCP server using sequential requests.  Makes three requests in sequence: 1. initialize - establish session and negotiate protocol 2. notifications/initialized - signal ready for operations 3. tools/list - get the actual tools list
     * Fetch Mcp Tools
     */
    async fetchMcpToolsApiV1PoliciesFetchMcpToolsPost(requestParameters: FetchMcpToolsApiV1PoliciesFetchMcpToolsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: any; }> {
        const response = await this.fetchMcpToolsApiV1PoliciesFetchMcpToolsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the current organisation policy (link to the active policy version).
     * Get Organisation Policy
     */
    async getOrganisationPolicyApiV1PoliciesOrganisationOrganisationIdGetRaw(requestParameters: GetOrganisationPolicyApiV1PoliciesOrganisationOrganisationIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OrganisationPolicyResponse>> {
        if (requestParameters['organisationId'] == null) {
            throw new runtime.RequiredError(
                'organisationId',
                'Required parameter "organisationId" was null or undefined when calling getOrganisationPolicyApiV1PoliciesOrganisationOrganisationIdGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/policies/organisation/{organisation_id}`;
        urlPath = urlPath.replace(`{${"organisation_id"}}`, encodeURIComponent(String(requestParameters['organisationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrganisationPolicyResponseFromJSON(jsonValue));
    }

    /**
     * Get the current organisation policy (link to the active policy version).
     * Get Organisation Policy
     */
    async getOrganisationPolicyApiV1PoliciesOrganisationOrganisationIdGet(requestParameters: GetOrganisationPolicyApiV1PoliciesOrganisationOrganisationIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OrganisationPolicyResponse> {
        const response = await this.getOrganisationPolicyApiV1PoliciesOrganisationOrganisationIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the latest N policy versions for an organisation (default 5).
     * List Policy Versions
     */
    async listPolicyVersionsApiV1PoliciesVersionsGetRaw(requestParameters: ListPolicyVersionsApiV1PoliciesVersionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PolicyVersionListResponse>> {
        if (requestParameters['organisationId'] == null) {
            throw new runtime.RequiredError(
                'organisationId',
                'Required parameter "organisationId" was null or undefined when calling listPolicyVersionsApiV1PoliciesVersionsGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['organisationId'] != null) {
            queryParameters['organisation_id'] = requestParameters['organisationId'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/policies/versions`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PolicyVersionListResponseFromJSON(jsonValue));
    }

    /**
     * List the latest N policy versions for an organisation (default 5).
     * List Policy Versions
     */
    async listPolicyVersionsApiV1PoliciesVersionsGet(requestParameters: ListPolicyVersionsApiV1PoliciesVersionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PolicyVersionListResponse> {
        const response = await this.listPolicyVersionsApiV1PoliciesVersionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Verify if a chatbot and user email are allowed by the user\'s organisation policy. Returns 200 on success or 403 if not permitted.
     * Verify Chatbot
     */
    async verifyChatbotApiV1PoliciesVerifyChatbotPostRaw(requestParameters: VerifyChatbotApiV1PoliciesVerifyChatbotPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['verifyChatbotRequest'] == null) {
            throw new runtime.RequiredError(
                'verifyChatbotRequest',
                'Required parameter "verifyChatbotRequest" was null or undefined when calling verifyChatbotApiV1PoliciesVerifyChatbotPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['useCache'] != null) {
            queryParameters['use_cache'] = requestParameters['useCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }


        let urlPath = `/api/v1/policies/verify-chatbot`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VerifyChatbotRequestToJSON(requestParameters['verifyChatbotRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Verify if a chatbot and user email are allowed by the user\'s organisation policy. Returns 200 on success or 403 if not permitted.
     * Verify Chatbot
     */
    async verifyChatbotApiV1PoliciesVerifyChatbotPost(requestParameters: VerifyChatbotApiV1PoliciesVerifyChatbotPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.verifyChatbotApiV1PoliciesVerifyChatbotPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
